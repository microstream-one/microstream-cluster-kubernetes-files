apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "es-cluster.proxy.fullname" . }}
  labels:
    {{- include "es-cluster.proxy.labels" . | nindent 4 }}
data:
  nginx.conf: |
    # Automatically figure out how many workers (threads) should be started based on the available cpu cores
    worker_processes auto;

    events {
      # The maximum number of simultaneous connections that can be opened by a worker process.
      # Check allowed open file limits per process with: `ulimit -n`
      # Most distros have a default limit of 1k
      worker_connections 1000;
    }
    
    http {
      # Disable access log to prevent spam
      access_log off;

      # Filter out HTTP 200-300 access logs. Keep others like HTTP 400 (user error) HTTP 500 (server error) 
      map $status $loggable {
        ~^[23]  0;
        default 1;
      }

      proxy_http_version 1.1;
      # The dns resolver inside the kubernetes cluster. If we don't add this nginx won't know how to resolve our subdomains like 'writerproxy'
      resolver kube-dns.kube-system.svc.cluster.local;

      # Map PUT|PATH|DELETE|POST requests to the writerproxy domain
      # Any modifying request that the cluster receives should go through the writerproxy
      # This node knows which storage node is the current writer and forwards the request to it
      {{- $writerproxy-domain := (printf "%s.%s.svc.cluster.local" (include "es-cluster.writer-proxy.fullname" .) .Release.Namespace) }}
      {{- $storagenode-domain := (printf "%s.%s.svc.cluster.local" (include "es-cluster.storage-node.fullname" .) .Release.Namespace) }}
      map $request_method $upstream_location {
        PUT    {{ $writerproxy-domain }};
        PATCH  {{ $writerproxy-domain }};
        DELETE {{ $writerproxy-domain }};
        POST   {{ $writerproxy-domain }};

        # Any other request can go to the node subdomain. This will go to a random storage node that the loadbalancer deems as sufficent.
        default {{ $storagenode-domain }};
      }
      
      server {
        # Listen for incoming connections on port 8080. The proxy service resource specifies which port you actually have to call, but
        # a good practise is to use 8080 inside the containers so we don't need to access the lower port number range
        listen 8080;

        location / {
          # Set some proxy header information
          proxy_set_header Host $proxy_host;
          proxy_set_header Connection close;
          # Select the correct subdomain and forward the request to it.
          # Internally the cluster communicates via http. All the https traffic should come from the outside to a configured ingress
          proxy_pass http://$upstream_location;
        }
      }
    }